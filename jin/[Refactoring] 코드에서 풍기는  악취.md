# 코드에서 나는 악취 - 1
## 읽기 전에..
이 글은 다소 개인 생각이 많이 포함된 글이니 걸러서 읽어 주셔야 합니다..

# 0. 리팩터링은 언제 해야 하는가?
리팩터링은 "언제" 해야 할까? <br>
리팩터링의 원리를 아는 것 만큼, 리팩터링을 언제 시작하고, 언제 그만할지 판단하는 일도 매우 중요하다. 대부분 모호한 기준을 가질 수 밖에 없다.  <br>
켄트 벡과 마틴 파울러는 결국 어느 정도 직관에 기댈 수 밖에 없다고 이야기한다. 다만 "징후"는 정리해볼 수 있다. 메서드가 몇 줄을 넘어가면 읽기가 어렵더라, Depth가 몇 칸을 넘어가면 읽기가 힘들더라 등의 "징후"는 정리해볼 수가 있다. <br>

켄트 백은 이런 코드들에 "악취"가 난다고 표현했다. 갓 태어난 딸을 돌보느라 기저귀 냄새에 예민해져 이런 표현을 썼다고 한다. 이 아티클에서는 그런 "악취나는 코드"에 대해서 정리해보겠다. 그리고 다음 아티클에서 악취 나는 코드들을 어떻게 해결할지 고민해본다. <br> 

일단 리스트 부터 정리해본다. 이 리스트는 도서 리팩터링에 소개된 내용과 내가 만난 레거시를 더한 리스트이다. 

1. 기이한 이름
2. 중복된 코드
3. 긴 함수
4. 긴 매개변수 목록
5. 전역 데이터
6. 가변 데이터
7. 뒤엉킨 변경
8. 산탄총 수술 (TODO)
9.  기능 편애
10. 데이터 뭉치들
11. 기본형에 대한 집착
12. 반복되는 Switch 문
13. 반복문
14. 성의 없는 요소들 (TODO)
15. 추측성 일반화
16. 임시 필드
17. 메시지 체인
18. 중개자
19. 내부자 거래
20. 거대한 클래스
21. 상속 포기
22. 주석
23. 길고 복잡한 조건문
24. 위험한 리터럴 사용
25. 어려운 도메인, 흩어진 상태들

# 1. Mysterious Name - 기이한 이름
코드는 읽기 좋아야 한다. 읽는 사람은 이 메서드가 어떤 책임을 갖고, 어떻게 동작하는지, 메서드 안의 변수 하나 코드 한줄이 어떤 역할을 하는지를 최대한 쉽게 파악할 수 있어야 한다. <br>

## 1.1 누가? 무엇을?
이것을 가장 쉽게 달성하는 방법은 클래스와 메서드, 각종 변수들의 이름을 명확히 하는 것이다. 메서드는 "행동" 변수는 "행동 주체" 혹은 주고 받는 "상태"를 주로 맡게 된다. **이들의 이름이 아주 명확하다면 코드 누가? 무엇을? 하는지 파악하기가 쉬워진다.** <br> 
**"어떻게"는 의도적으로 뺐다. 코드에서의 "어떻게"는 중요하지만, 나는 숨기는 것을 선호한다.** 예를 들어 함수 중간에 "예매하기" 코드가 들어가야 한다면, 나는 "예매하기" 메서드를 만들고 그것이 어떻게 동작하는지는 메서드 안에 캡슐화해 숨긴다. <br> 
1. 그래야 의존성이 낮아진다. -> Caller는 어떻게 동작하는지를 몰라도 메서드를 이용할 수 있다. 인터페이스를 사용하는 핵심 이유이기도 하다
2. 읽는 사람이 알아서 메서드 전체를 이해하고 싶을 때는 무엇을 하는지만 빠르게 파악하고, 어떻게 동작하는지를 파악할 때만 들어가볼 수 있기 때문이다.

<br> <br>

## 1.2 금융권에서 근무하는 내가 만나온 사례들
### 1.2.1 같은 내용 다른 표현
결론적으로 함수, 모듈, 변수, 클래스는 매우 신경써서 이름을 지어야 한다. 읽으면서 의미를 파악할 수 있어야 하고, 최대한 표현과 스펠링이 같아야한다. 내가 근무하며 만난 코드 중에는 "한글"을 Hangul, 혹은 Hangual로 표현한 메서드를 봤었다. 같은 클래스는 아니였지만, 같은 패키지의 Util 클래스였다. 
이 경우엔 이해하는덴 문제가 안 됐지만, 나는 금융권에 있다 보니 어려운 용어를 서로 다르게 쓸 때가 있어 난감했다. <br>
그래서 내 생각엔 둘 중 하나의 조치가 필요하다.
1. 합의된 용어집이 있어야 한다.
2. (가능하다면) IDE가 오타를 잡아주는 툴에 해당 단어를 추가한다. 
3. 코드 리뷰가 필요하다. -> 잘못 쓰는 경우가 있으면 서로 봐주면 좋을 것이다.


### 1.2.2 최대한 단어를 줄이려는 노력

또한 내가 만나는 레거시들은 단어를 최대한 줄이려고 노력하고 있다. 경력이 30년 가까이 되는 분께서도 저에게 어떤 고객사는 단어를 절대 줄여 쓰지 못하게 했는데, 너무나도 불편했다고 말씀하셨었다. <br> 
그만큼 긴 변수명이나 메서드명을 줄이는 것은 옛날엔 흔한 관례였던것 같다. 나는 항상 모든 일의 원인을 파악하려고 노력하는데, 예전의 불편한 모니터와 IDE상에선 아마도 긴 변수나 메서드명을 읽기 쉽지 않았을 것이다. Depth가 깊어지는 것을 크게 신경쓰지 않는 것과는 조금 대비되서 의아한 부분이다. <br> 

또한 SI 업계는 다른 사람이 짠 코드를 읽을 일이 극히 드물기 때문에, 자신만 알아볼 수 있으면 괜찮은 경우가 많았을 것이므로, 작성하기도 편하고 짧아서 빠르게 읽을 수 있으므로 줄였을 것도 같다. <br>

단어를 줄이는 것이 항상 나쁜 것은 아니다. 이미 너무 잘 알려진 단어들은 줄여도 무방하다고 생각한다. Database를 DB로, Application을 App으로 줄여도 웬만해선 읽는 사람이 이해할 수 있을 것이다. 하지만, 평소 줄여 부르지 않는 용어를 줄이는 것은 문맥 파악에 큰 방해가 된다고 생각한다. <br> 

그래서 안그래도 어려운 금융 용어를 줄여진채로 만나야 해서 파악하기가 매우 곤란한 상황이 많았다. 또한 같은 단어를 서로 다르게 줄일 때도 많아서 굉장히 혼란스럽다. <br> 

**물론 무조건 verbose 하자고 하는 것은 아니다. 무조건 긴 변수나 메서드는 읽기 힘들다. 내 경험에 따르면 줄이려면 차라리 아래와 같이 줄였으면 좋겠다.**

1. **합의된 줄임말을 사용한다.**
2. **단어를 줄이려면 중간에 자르는게 낫다고 생각한다. 아닌 경우 그냥 줄이지 않았으면 좋겠다. -> 검색 할 수가 없기 때문이다.** <br> 

예를 들어 Select, Insert, Delete, Update를 줄여 Sel, Ins, Del, Upd라고 쓰는 경우를 정말 많이 봤는데, 이 경우엔 검색해서 찾기가 쉬웠다. 예를 들어 컨트롤 + F를 누르고 "Sel"이라고 치면 바로 찾을 수 있다. (물론 맨 처음 메서드에서 쓰인 Ins를 보았을 때는 이해하지 못했었다) <br> 

하지만, Customer를 Cutm으로 줄이는 경우를 보았다. 2006년도였나 작성된 코드였던 것 같은데, 일단 Cus로 검색하다가 못 찾아서 결국 소스를 계속 읽었다. 그리고 Cutm만 딱 놓여있다면 무슨 뜻인지 알 수 있을까? (문제는 이런 줄임말이 정말 정말 많다는 것이다.)

## 1.3 읽는 사람이 빠르게 이해할 수 있는 이름을 지어보자
수능 비문학 문제를 풀며 모르는 단어가 나오면, 맥락을 통해 파악하곤 했다. 이게 가능했던 이유는 비문학 지문은 다양한 요소를 통해 맥락을 제공하기 때문이고, 단어가 어려울 뿐이지 추론할 장치들을 주었기 때문이다. ("하지만" 이후 이전 문장과 반대되는 내용이 오는 등..) <br> 

**하지만 코드는 맥락이 변수와 메서드로 주어지는 경우가 많다. 아까 이들을 "행동"과 "주체" 라고 표현하지 않았는가?** 문장에서 행동과 주체를 파악할 수 수 없다면 맥락을 파악할 수가 없다.. <br> <br>

물론 제대로 된 이름을 짓는 것은 매우 어렵다는 것을 잘 알고 있다. 필 칼튼은 "컴퓨터 과학에서 가장 어려운 것은 딱 두가지이다. 캐시 무효화와 이름 짓기이다"라고도 말했었다. <br>
그래도 대게 **"무엇을"에 집중해** 머리를 싸메고 고민해보면 좋은 이름이 나온다 이 메서드는 무엇을 하려는 건지? 이 클래스는 어떤 책임을 갖는건지? 등 "무엇을"에 집중해 이름을 지으면 좋다. **그리고 코드 리뷰를 통해 여러 사람과 함께 고민하면 아주 멋진 이름이 나올 때가 많다.** <br>
**딱히 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 수도 있다.** 이 변수나 메서드가 맡은 역할이 너무 많아 하나의 이름을 짓기 어려운 것일 수도 있다. **나는 직원들에게 먹일 요리도, 하고 범죄자도 소탕하고, 돈을 받고 공연을 하기도 한다 나는 누구일까? 단 한마디로 표현할 수 없다.** <br>

### 결론
1. 읽는 사람이 이해하기 쉬운 이름을 짓는다.
2. 여러 사람과 함께 고민하면 좋은 이름이 잘 나온다.
3. "어떻게"가 아닌 **"무엇을"에 집중한다.** **의도에 집중한다.** -> 이 메서드는 무엇을 하려 한다..
4. 마땅한 이름이 떠오르지 않는다면 설계에 문제가 있을 수도 있다.


# 2. Duplicated Code - 중복 코드
똑같은 코드 구조가 여러곳에서 반복된다면, 하나로 통합하여 더 나은 프로그램을 만들자. 물론 작은 차이점이 있을 수도 있으니 이에 주의하여 캡슐화 해보자. <br> 
**운이 좋으면 파라미터로 만들 수도 있다.** 상태만 다른거라면 파라미터로 만들 수도 있고, 작은 단위의 행동만 다른 것이라면 람다를 활용할 수도 있다. 혹은 비슷한 부분만 일단 추출해보는 시도도 좋다. <br>
운이 더욱 좋아 같은 부모로 부터 파생된 서브 클래스의 코드들이라면, 상위 클래스에서 호출되게 할 수도 있겠다. 

1. 다른 부분이 없다면 메서드로 분리
2. 다른 부분이 있다면
   1. 다른 부분이 상태라면 다른 부분을 파라미터화 해서 해결할 수 있는지 확인한다.
   2. 행위라면 람다를 활용해본다.
3. 혹은 추출 가능한 부분만 분리하는 것만 해도 좋다.
4. 만약 같은 부모로 부터 파생됐고 내용이 같다면 상위 클래스로 옮겨 호출해도 좋을 것이다.


# 3. 긴 함수 - Long Funciton
## 3.1 왜 레거시 메서드들은 길까
레거시 함수들은 왜 하나같이 무서울만큼 긴 것일까? 얼마 전에는 거의 만줄에 가까운 메서드를 마이그레이션 해야 하는 동료분의 이야기를 들었다. <br>
우선 앞서 언급했던 이유들과 같이 내가 읽을 수 있기만 하면 되어서 그랬을 수도 있다. 이런 당연한 이유를 빼고 고민해 봤을 때 결국 옛 방식에 익숙해서 그랬을 것이라는 결론이 났다. **결국 옛날 방식에 익숙해서 그랬을 것이다.**
1. 옛날의 절차지향 방식 + 변수 선언과 할당을 따로 하는 구조에 익숙하다
2. 예전엔 서브 루틴 호출 비용이 커 짧은 함수를 피했다고 한다 (책에 따르면) 
3. 옛날 IDE는 함수를 왔다갔다 하는게 매우 어려웠을 것이다. 따라서 짧은 메서드를 여러개 만드는 사람은 귀찮게 하는 사람이었을 것이다.

<br>

## 3.2 주석을 달고 싶다면 메서드로 쪼게어라

마틴 파울러의 말에 따르면, 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 메서드로 구성되어 있다고 한다. 이 메서드들은 서로가 서로에게 계속해서 연산을 위임한다. 여기에 이름까지 잘 지은다면 코드의 의도를 매우 파악하기 쉬워진다. 본문을 볼 필요도 없을 수도 있다. <br> 
특히 현대 IDE의 힘을 빌린다면 함수와 함수 사이를 오가는 것은 그리 어려운 일이 아니다. <br> 
**주석을 달고 싶다면 메서드로 쪼겐다.** 주석을 달고 싶다는 것은 작성하는 사람이 생각 했을 때, 코드가 아닌 코멘트가 있어야 이 코드를 더 쉽게 이해할 수 있겠다는 판단이 들었다는 것이다. <br> 

메서드로 쪼게는 순간 일단 이름을 지어줄 수 있다. 주석을 달고 싶었던 부분에 대해 설명할 수 있게 되는 것이다. **코드의 의도와 목적을 드러낼 수 있게 되는데, 마틴 파울러는 원래 코드보다 더 길어지더라도, 코드가 단 한줄일지라도, 필요하다면 뽑아낸다고 한다.**  <br>

## 3.3 함수 추출하기
**함수를 짧게 만드는 작업의 99%는 함수를 추출하는 일이다.** <br>
함수를 추출하는 방법들을 알아보자.

### 3.3.1 추출 함수의 매개변수가 너무 많은 경우
만약 함수와 매개변수가 임시 변수를 많이 사용한다면 추출한 함수도 많은 매개변수가 있을 수 있어 더 난해해질 수도 있다. 그럴때 아래와 같은 방법을 권한다고 한다.

1. `매개변수 객체로 만들기` : DTO를 만들거나 객체를 통째로 넘길 수 있다. - 만약 이전 메서드에서 DTO 객체의 값들을 뽑아서 메서드에 인수로 넣어주는 것이였다면, 그냥 다시 활용해도 좋다. 단, 계층간 혹은 메서드간 의도적으로 정보를 제한한 것이라면, 차라리 새로운 DTO를 만드는게 나을 것 같다. <br> (ex Member 객체가 가진 정보 5개 중 3개만 메서드의 인수로 들어가게 되고, 나머지 2개는 숨겨야 하는 상황에서 Member 객체를 보내는 것은 잘못됐다.)
2. `임시로 사용하는 변수 줄이기` : 매개 변수를 질의 함수로 바꾸어보라 임시 변수는 보통 어떤 코드의 결과값을 나중에 다시 잠조하기 위해 사용한다. 예를 들어 어어떤 계산 결과를 나중에 또 사용하기 위해 변수를 사용할 수 있는데


### 3.3.2 조건문과 반복문을 추출해보자
1. **조건문의 내용, Switch문의 Case 본문들을 하나의 함수로 추출할 수 있다.** 이렇게 하면 **A인 경우 치킨을 먹어라. B인 경우 피자를 먹어라와 같이 어떤 조건일 때 무엇을 할지 쉽게 드러낼 수 있다.**
2. Switch문이 여러개라면 조건부 로직을 다형성으로 바꿔라.
3. **반복문 안의 코드를 추출해 함수로 만들자** -> Java Stream에서 아주 많이 하는 일인데, 외부 반복을 내부 반복으로 바꾼다. 
  for문을 통해 List의 원소 하나 하나에 어떤 처리를 할 때, 코드가 길어질 수록 무엇을 하는지 정확히 파악하기 힘들다. **이를 메서드로 추출한다면 하나의 단어로 바꿀 수 있는 것이다.** 
  순회하며 -> 값을 필터링한다, 하나 하나 객체로 변환한다, 어떤 처리를 한다 등 복잡한 for문에 대해 이해할 필요 없이 쉽게 의도를 파악할 수 있다.
  **만약 반복문을 추출할 때 적합한 이름이 떠오르지 않는다면, 성격이 다른 여러 작업들이 반복문 안에 섞여 있는 것이다.** 이럴 때 반복문을 쪼갤 수 있다.

### 3.3.3 메서드 길이를 줄이는 다른 방법들
1. 임시 변수를 질의 함수로 바꾸기 : 보통 메서드 안에서 어떤 변수를 선언해 사용할 때는 어떤 결과를 메서드 내의 다른 곳에서 또 사용하기 때문이다. 만약 해당 변수를 만들기 위한 계산은 한번이고, 그 뒤엔 읽기만 한다면 클래스의 다른 메서드로 바꿀 수 있다. 특히, 다른 메서드에서도 이 변수를 활용한다면 메서드로 빼는 것이 좋은 선택이다. <br> 예를 들어 어떤 어떤 양과 가격의 곱을 계산해 어떤 변수를 만든다고 생각해보자. 가격과 곱을 마침 Class가 맴버 변수로 가지고 있다면, 가격 계산 메서드를 따로 만들기 아주 좋다.
2. `함수를 명령으로 바꾸기` : 함수가 긴 이유가 응집도가 낮은 상황이라면, 아예 다른 클래스의 함수로 분리하라는 의미이다. 예를 들어 어떤 메서드 안에서 어떤 클래스가 하나의 역할을 할 때 이를 명령 클래스라고 부르기 때문에 이런 용어가 나왔다. <br> 예를 들어 어떤 메서드에서 요리도, 하고 범죄자도 잡고, 노래도 부른다면 요리사, 경찰, 가수 클래스에게 각각 메서드를 주고 명령할 수 있다.

<br>

# 4. Long Parameter List - 긴 매개변수 목록
1. 매개변수 객체 만들기 : 많은 함수에서 사용되는, 세트로 몰려다니는 파라미터들이 있다면 하나의 객체로 만들어 두는 것도 좋다. (적당한 역할을 부여해줄 수 있다면)
2. 플래그 인수 제거하는 법 : (매개변수 하나를 줄이기 위한 조치로는 조금 과해 보이긴 한다. 감안하고 봐주시길..) <br> 어떤 조건 단 하나로, 함수의 동작 방식이 바뀌는 경우가 있다. 이를 플래그 인수라고 한다. 예를 들어 손에 포크를 들고 있는지, 젓가락을 들고 있는지에 따라 먹는 방식이 달라지는 경우, 플래그는 식기이다. <br> 플래그 인수는 잘 만들지 않으면, 어떤 플래그가 있고 플래그별로 어떻게 행동이 다른지 알기 어렵다고 한다. <br> 예를 들어 아래 코드를 확인해보자.

```java
deliveryDate = getDeliveryDate(order, true);

...

deliveryDate = getDeliveryDate(order, false);
```

여기서 메서드의 2번째 파라미터가 플래그로써 쓰이는데, 대체 이게 뭘 의미할까

```java
// 예제이기 때문에 냄새 포인트가 많아도 너그럽게 용서 바랍니다!!
public LocalDate getDeliveryDate(Order order, boolean isRush) {
  if (isRush) {
    int deliveryTime;
    if (order.getState() == OrderState.MA || order.getState() == OrderState.CT) deliveryTime = 1;
    else if (order.getState() == OrderState.NY || order.getState() == OrderState.NH) deliveryTime = 2;
    else deliveryTime = 3;

    return order.getPlaceOn.plusDays(1 + deliveryTime);
  }

  int deliveryTime;
    if (order.getState() == OrderState.MA || order.getState() == OrderState.CT || order.getState() == OrderState.NY) deliveryTime = 2;
    else if (order.getState() == OrderState.ME || order.getState() == OrderState.NH) deliveryTime = 3;
    else deliveryTime = 4;

    return order.getPlaceOn.plusDays(2 + deliveryTime);
}
```

이 코드에서 일단 조건문을 분해해보자. <br>

```java
// 예제이기 때문에 냄새 포인트가 많아도 너그럽게 용서 바랍니다!!
public LocalDate getDeliveryDate(Order order, boolean isRush) {
  if (isRush) {
    return getRushDeliveryDate(order);
  }
  return getRegularDeliveryDate(order);
}

private LocalDate getRushDeliveryDate(Order order) {
  int deliveryTime;
  if (order.getState() == OrderState.MA || order.getState() == OrderState.CT) {
    deliveryTime = 1;
  }
  else if (order.getState() == OrderState.NY || order.getState() == OrderState.NH) {  
    deliveryTime = 2;
  }
  else { 
    deliveryTime = 3;
  }

  return order.getPlaceOn.plusDays(1 + deliveryTime);
}

private LocalDate getRegularDeliveryDate(Order order) {
  int deliveryTime;
  if (order.getState() == OrderState.MA || order.getState() == OrderState.CT || order.getState() == OrderState.NY) {
    deliveryTime = 2;
  }
  else if (order.getState() == OrderState.ME || order.getState() == OrderState.NH) {
    deliveryTime = 3;
  }
  else {
    deliveryTime = 4;
  }

  return order.getPlaceOn.plusDays(2 + deliveryTime);
}
```
책에선 여기까지만 했는데, 더 나눠보면 좋을거 같다. 
```java
// 예제이기 때문에 냄새 포인트가 많아도 너그럽게 용서 바랍니다!!
public LocalDate getDeliveryDate(Order order, boolean isRush) {
  if (isRush) {
    return getRushDeliveryDate(order);
  }
  return getRegularDeliveryDate(order);
}

private LocalDate getRushDeliveryDate(Order order) {
  int deliveryTime = getRushDeliveryTime(order.getState());
  return order.getPlaceOn.plusDays(1 + deliveryTime);
}

private int getRushDeliveryTime(OrderState state) {
  if (state == OrderState.MA || state == OrderState.CT) {
    return 1;
  }
  if (state == OrderState.NY || state == OrderState.NH) {  
    return 2;
  }
  return 3;
}

private LocalDate getRegularDeliveryDate(Order order) {
  int deliveryTime = getRegularDeliveryTime(order.getState());
  return order.getPlaceOn.plusDays(2 + deliveryTime);
}

private int getRushDeliveryTime(OrderState state) {
  if (state == OrderState.MA || state == OrderState.CT || state == OrderState.NY) {
    return 2;
  }
  if (state == OrderState.ME || state == OrderState.NH) {
    return 3;
  }
  return 4;
}
```


그 다음 아래와 같이 플래그를 없앨 수 있을 것이다.

```java
// Before
deliveryDate = getDeliveryDate(order, true);
... 생략
deliveryDate = getDeliveryDate(order, false);


// After
deliveryDate = getRushDeliveryDate(order);
... 생략
deliveryDate = getRegualarDeliveryDate(order);
```

이렇게하면 더 의도도 잘 드러나고, 파라미터가 많은 경우 파라미터도 줄일 수 있다.
# 5. Global Data - 전역 데이터
